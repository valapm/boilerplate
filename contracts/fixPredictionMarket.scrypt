import "util.scrypt";
import "./fixLmsr.scrypt";
import "./merkleTree.scrypt";
import "./rabin.scrypt";

// TODO: Variable fee per trade for market creator
// TODO: Flat fee per trade for myself
// TODO: Flat fee per trade for oracle

// TODO: Add market creator pubKey to opReturn data
// TODO: Market creator can sell all invalid shares when market is resolved, add to updateEntry

contract PM {
  bytes oracleKeys;
  int globalOptionCount;
  int requiredVotes;

  static const int MaxOptionCount = 6; // Maximum number of outcomes
  static const int MaxOracleCount = 3; // Maximum number of oracles for resolving the market

  static const int satScaling = 1048576; // 2^20
  static const int fixMathScaling = 65536; // 2^16
  static const int satScalingAdjust = 16; // satStacling - fixMathScaling =) 2^4

  static const int balanceTableLength = 32;

  static const int entryLiqudityPos = 32;
  static const int entrySharePos = 33;

  // Oracles
  static const int rabinSigN = 0;
  static const int rabinKeyLength = 126;
  static const int oracleLength = 127; // rabin key + 1 byte
  static const int signatureLength = 128; // rabin key + 2 bytes

  /**
  * Everything is done in one function to reduce script size.
  */
  public function updateMarket(
    SigHashPreimage txPreimage,
    int action, // 0 = add entry; 1 = update entry

    bytes entry,

    // Inputs required for adding new entry
    bytes lastEntry,
    bytes lastMerklePath,

    // Inputs required for modifying entry
    int prevLiquidity,
    bytes prevShares,
    Sig signature,
    bytes merklePath
    ) {

    // OP_PUSHTX with AnyoneCanPay and Sighash Single
    SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.SINGLE | SigHash.FORKID;
    require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

    // Entract entry paramerters
    PubKey publicKey = PubKey(entry[ : entryLiqudityPos]);
    int newLiquidity = unpack(entry[entryLiqudityPos : entrySharePos ]);
    bytes newShares = entry[entrySharePos : ];

    // Extract current state parameters
    bytes scriptCode = Util.scriptCode(txPreimage);
    int scriptLen = len(scriptCode);
    int balanceTableRootPos = scriptLen - balanceTableLength;
    int sharePos = balanceTableRootPos - this.globalOptionCount;

    bytes balanceTableRoot = scriptCode[balanceTableRootPos : ];
    bytes prevGlobalShareStatus = scriptCode[sharePos : balanceTableRootPos];
    int prevGlobalLiquidity = unpack(scriptCode[sharePos - 1 : sharePos]);

    require(newLiquidity >= 0);

    // Verify that right amount of shares are passed. TODO: Might be unnecessary
    int shareCount = len(newShares);
    require(shareCount == this.globalOptionCount);

    int newGlobalLiquidity = 0;
    bytes newGlobalShareStatus = b'';
    bytes newBalanceTableRoot = b'';

    int redeemShares = 0; // Only relevant for redeeming shares

    if (action == 0) {
      // Add new entry

      newGlobalLiquidity = prevGlobalLiquidity + newLiquidity;

      int i = 0;
      loop (MaxOptionCount) {
        if (i < this.globalOptionCount) {
          int entryShares = unpack(newShares[i : i + 1]);
          require(entryShares >= 0);

          int newShares = unpack(prevGlobalShareStatus[i : i + 1]) + entryShares;
          newGlobalShareStatus += num2bin(newShares, 1);
        }
      }

      bytes newLeaf = sha256(
        publicKey
        + num2bin(newLiquidity, 1)
        + newShares
        );

      bytes newBalanceTableRoot = MerkleTree.addLeafSafe(lastEntry,
        lastMerklePath,
        balanceTableRoot,
        newLeaf);

    }
    else if (action == 1) {
      // Update Entry

      require(checkSig(signature, publicKey));

      // Extract decision status
      int decisionPos = sharePos - 2;
      bytes decisionStatus = scriptCode[decisionPos : sharePos];

      int isDecided = unpack(decisionStatus[ : 1]);
      int decision = unpack(decisionStatus[1 : 2]);

      int liquidityChange = newLiquidity - prevLiquidity;
      newGlobalLiquidity = prevGlobalLiquidity + liquidityChange;

      int i = 0;
      loop (MaxOptionCount) {
        if (i < this.globalOptionCount) {
          int entryShares = unpack(newShares[i : i + 1]);
          require(entryShares >= 0); // Might be unnecessary

          int prevShares = unpack(prevShares[i : i + 1]);
          int shareChange = entryShares - prevShares;

          if (isDecided == 1) {
            if (i == decision) {
              if (shareChange != 0) require(liquidityChange == 0); // For complexity reasons disallow redeeming and changing liquidity at the same time.
              redeemShares = shareChange;
            } else {
              require(shareChange == 0); // Prevent selling of loosing shares after market is resolved
            }
          }

          int newShares = unpack(prevGlobalShareStatus[i : i + 1]) + shareChange;
          newGlobalShareStatus += num2bin(newShares, 1);
        }
      }

      bytes oldLeaf = sha256(
        publicKey
        + num2bin(prevLiquidity, 1)
        + prevShares
        );

      bytes newLeaf = sha256(
        publicKey
        + num2bin(newLiquidity, 1)
        + newShares
        );

      newBalanceTableRoot = MerkleTree.updateLeaf(oldLeaf,
        newLeaf,
        merklePath,
        balanceTableRoot);

    } else {
      require(false);
    }

    // Determine new contract sat balance
    int newBalance = 0;
    if (redeemShares != 0) {
      // User only sold winning shares
      int redeemSats = redeemShares * PM.satScalingAdjust;
      int newBalance = Util.value(txPreimage) - redeemSats;
    } else {
      // Market is either unresolved or user only changed liquidity
      int newLmsrBalance = FixLMSR.lmsr(newGlobalShareStatus, newGlobalLiquidity);
      int newBalance = newLmsrBalance * PM.satScalingAdjust; // Need to be 2^20 * lmsr output
    }

    bytes newScriptCode = scriptCode[ : sharePos] + newGlobalShareStatus + newBalanceTableRoot;

    int prevBalance = Util.value(txPreimage);

    bytes marketOutput = Util.buildOutput(newScriptCode, newBalance);

    require(hash256(marketOutput) == Util.hashOutputs(txPreimage));
  }

  public function decide(SigHashPreimage txPreimage,
    int result,
    bytes oracleSigs
    ) {

    SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.SINGLE | SigHash.FORKID;
    require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

    bytes scriptCode = Util.scriptCode(txPreimage);
    int scriptLen = len(scriptCode);
    int balanceTableRootPos = scriptLen - balanceTableLength;
    int sharePos = balanceTableRootPos - this.globalOptionCount;
    int decisionPos = sharePos - 2;

    bytes balanceTableRoot = scriptCode[balanceTableRootPos : ];
    bytes shareStatus = scriptCode[sharePos : balanceTableRootPos];
    int prevGlobalLiquidity = unpack(scriptCode[sharePos - 1 : sharePos]);
    bytes decisionStatus = scriptCode[decisionPos : sharePos];

    int isDecided = unpack(decisionStatus[ : 1]);
    if (isDecided) exit(false);

    require(result >= 0 && result < this.globalOptionCount);

    RabinSignature rabin = new RabinSignature();

    int oracles = len(this.oracleKeys) / oracleLength;
    int oracleSigsLen = len(oracleSigs) / signatureLength;
    int votes = 0;
    int i = 0;
    int lastMinerPos = - 1;
    loop (MaxOracleCount) {
      if (i < oracleSigsLen) {
        int oraclePos = unpack(oracleSigs[i * signatureLength : i * signatureLength + 1]);

        // Make sure no signature is used twice
        require(oraclePos > lastMinerPos);
        lastMinerPos = oraclePos;

        int oraclePubKey = unpack(this.oracleKeys[oraclePos * oracleLength : oraclePos * oracleLength + rabinKeyLength]);
        int oracleSig = unpack(oracleSigs[i * signatureLength + 1 : i * signatureLength + rabinKeyLength + 1]);
        int paddingCount = unpack(oracleSigs[i * signatureLength + rabinKeyLength + 1 : i * signatureLength + signatureLength]);
        bytes padding = num2bin(0, paddingCount);

        require(rabin.verifySig(oracleSig, num2bin(result, 1), padding, oraclePubKey));

        votes = votes + unpack(this.oracleKeys[oraclePos * oracleLength + rabinKeyLength : oraclePos * oracleLength + oracleLength]);
        i = i + 1;
      }
    }
    require(votes > this.requiredVotes);

    bytes newDecisionStatus = b'01' + num2bin(result, 1);
    bytes newScriptCode = scriptCode[ : decisionPos] + newDecisionStatus + scriptCode[sharePos : ];

    bytes marketOutput = Util.buildOutput(newScriptCode, Util.value(txPreimage));

    require(hash256(marketOutput) == Util.hashOutputs(txPreimage));
  }
}








