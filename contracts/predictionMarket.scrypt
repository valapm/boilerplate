import "util.scrypt";
import "./lmsr.scrypt";
import "./merkleTree.scrypt";
import "./rabin.scrypt";

contract PM {
  // int[] minerKeys; // PubKeys of voting miners
  // int[] minerVotes; // Must add to 100
  bytes minerKeys;

  // TODO: fee for liquidity providers?
  // TODO: Fee for myself

  static int satScaling = 1048576;
  static int satScalingAdjust = 32768;
  static int rabinSigN = 0;

  public function addEntry(SigHashPreimage txPreimage,
    int liquidity,
    int sharesFor,
    int sharesAgainst,
    Ripemd160 changePKH,
    PubKey publicKey,
    int changeSats,
    int newLmsrBalance,
    bytes newLmsrMerklePath,
    bytes lastEntry,
    bytes lastMerklePath) {

    SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.ALL | SigHash.FORKID;
    require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

    require(liquidity >= 0);
    require(sharesFor >= 0);
    require(sharesAgainst >= 0);

    bytes scriptCode = Util.scriptCode(txPreimage);
    int scriptLen = len(scriptCode);

    bytes balanceTableRoot = scriptCode[scriptLen - 32 : ];
    bytes shareStatus = scriptCode[scriptLen - 35 : scriptLen - 32];

    int prevLiquidity = unpack(shareStatus[ : 1]);
    int prevSharesFor = unpack(shareStatus[1 : 2]);
    int prevSharesAgainst = unpack(shareStatus[2 : 3]);

    int newLiquidity = prevLiquidity + liquidity;
    int newSharesFor = prevSharesFor + sharesFor;
    int newSharesAgainst = prevSharesAgainst + sharesAgainst;

    require(LMSR.validate(newLiquidity,
        newSharesFor,
        newSharesAgainst,
        newLmsrBalance,
        newLmsrMerklePath));

    bytes newLeaf = sha256(
      publicKey
      + num2bin(liquidity, 1)
      + num2bin(sharesFor, 1)
      + num2bin(sharesAgainst, 1)
      );

    bytes newBalanceTableRoot = MerkleTree.addLeafSafe(lastEntry,
      lastMerklePath,
      balanceTableRoot,
      newLeaf);

    bytes newSharesStatus = num2bin(newLiquidity, 1)
    + num2bin(newSharesFor, 1)
    + num2bin(newSharesAgainst, 1);
    bytes newScriptCode = scriptCode[ : scriptLen - 35] + newSharesStatus + newBalanceTableRoot;

    int prevBalance = Util.value(txPreimage);

    int newBalance = newLmsrBalance / PM.satScalingAdjust;

    bytes marketOutput = Util.buildOutput(newScriptCode, newBalance);

    // Expect the additional CHANGE output
    bytes changeScript = Util.buildPublicKeyHashScript(changePKH);
    bytes changeOutput = Util.buildOutput(changeScript, changeSats);

    Sha256 hashOutputs = hash256(marketOutput + changeOutput);

    require(hashOutputs == Util.hashOutputs(txPreimage));
  }

  public function updateEntry(SigHashPreimage txPreimage,
    int liquidity,
    int sharesFor,
    int sharesAgainst,
    int prevLiquidity,
    int prevSharesFor,
    int prevSharesAgainst,
    Ripemd160 changePKH,
    PubKey publicKey,
    Sig signature,
    int changeSats,
    int newLmsrBalance,
    bytes newLmsrMerklePath,
    bytes merklePath) {

    SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.ALL | SigHash.FORKID;
    require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

    require(liquidity >= 0);
    require(sharesFor >= 0);
    require(sharesAgainst >= 0);

    require(checkSig(signature, publicKey));

    bytes scriptCode = Util.scriptCode(txPreimage);
    int scriptLen = len(scriptCode);

    bytes balanceTableRoot = scriptCode[scriptLen - 32 : ];
    bytes shareStatus = scriptCode[scriptLen - 35 : scriptLen - 32];

    int prevGlobalLiquidity = unpack(shareStatus[ : 1]);
    int prevGlobalSharesFor = unpack(shareStatus[1 : 2]);
    int prevGlobalSharesAgainst = unpack(shareStatus[2 : 3]);

    int liquidityChange = liquidity - prevLiquidity;
    int sharesForChange = sharesFor - prevSharesFor;
    int sharesAgainstChange = sharesAgainst - prevSharesAgainst;

    int newGlobalLiquidity = prevGlobalLiquidity + liquidityChange;
    int newGlobalSharesFor = prevGlobalSharesFor + sharesForChange;
    int newGlobalSharesAgainst = prevGlobalSharesAgainst + sharesAgainstChange;

    require(LMSR.validate(newGlobalLiquidity,
        newGlobalSharesFor,
        newGlobalSharesAgainst,
        newLmsrBalance,
        newLmsrMerklePath));

    bytes oldLeaf = sha256(
      publicKey
      + num2bin(prevLiquidity, 1)
      + num2bin(prevSharesFor, 1)
      + num2bin(prevSharesAgainst, 1)
      );

    bytes newLeaf = sha256(
      publicKey
      + num2bin(liquidity, 1)
      + num2bin(sharesFor, 1)
      + num2bin(sharesAgainst, 1)
      );

    bytes newBalanceTableRoot = MerkleTree.updateLeaf(oldLeaf,
      newLeaf,
      merklePath,
      balanceTableRoot);

    bytes newSharesStatus = num2bin(newGlobalLiquidity, 1)
    + num2bin(newGlobalSharesFor, 1)
    + num2bin(newGlobalSharesAgainst, 1);
    bytes newScriptCode = scriptCode[ : scriptLen - 35] + newSharesStatus + newBalanceTableRoot;

    int prevBalance = Util.value(txPreimage);

    int newBalance = newLmsrBalance / PM.satScalingAdjust;

    bytes marketOutput = Util.buildOutput(newScriptCode, newBalance);

    // Expect the additional CHANGE output
    bytes changeScript = Util.buildPublicKeyHashScript(changePKH);
    bytes changeOutput = Util.buildOutput(changeScript, changeSats);

    Sha256 hashOutputs = hash256(marketOutput + changeOutput);

    require(hashOutputs == Util.hashOutputs(txPreimage));
  }

  // public function redeem(SigHashPreimage txPreimage,
  //   int liquidity,
  //   int sharesFor,
  //   int sharesAgainst,
  //   Ripemd160 changePKH,
  //   PubKey publicKey,
  //   Sig signature,
  //   int changeSats,
  //   bytes merklePath,
  //   // int[] minerPos,
  //   bool[] minerPos,
  //   Sig[] minerSigs) {

  //   require(true);
  // }

  // public function testSigs(bytes result,
  //   bool[] minerPos,
  //   int[] minerSigs,
  //   int[] paddingByteCounts) {
  //   require(this.isDecided(result, minerPos, minerSigs, paddingByteCounts));
  // }

  // function isDecided(bytes result,
  //   bool[] minerPos,
  //   int[] minerSigs,
  //   int[] paddingByteCounts) : bool {

  //   RabinSignature rabin = new RabinSignature();

  //   int miners = len(this.minerKeys) / 33;
  //   int percentage = 0;
  //   int i = 0;
  //   int j = 0;
  //   loop (10) {
  //     if (i < miners) {
  //       if (minerPos[i]) {
  //         int minerSig = minerSigs[j];
  //         int minerPubKey = unpack(this.minerKeys[i * 33 : i * 33 + 32]);
  //         bytes padding = num2bin(0, paddingByteCounts[j]);

  //         require(rabin.verifySig(minerSig, result, padding, minerPubKey));

  //         percentage = percentage + unpack(this.minerKeys[i * 33 + 32 : i * 33 + 33]);
  //         j = j + 1;
  //       }
  //       i = i + 1;
  //     }
  //   }
  //   return percentage >= 50;
  // }
}

