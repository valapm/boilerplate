const { buildContractClass, toHex, signTx, Ripemd160, Sig, PubKey, bsv, Bool, Bytes, compile, num2bin, getPreimage } = require('scryptlib');

const {
  deployContract,
  createInputFromPrevTx,
  sendTx,
  showError,
  loadDesc,
  sighashType2Hex
} = require('../helper')

const MSB_THRESHOLD = 0x7e;
const Signature = bsv.crypto.Signature;
const sighashType = Signature.SIGHASH_ANYONECANPAY | Signature.SIGHASH_SINGLE | Signature.SIGHASH_FORKID;
const { privateKey } = require('../privateKey');
const woc = 'https://test.whatsonchain.com/tx/';

function generatePreimage(isOpt, tx, lockingScriptASM, satValue, sighashType, idx = 0) {
  let preimage = null;
  if (isOpt) {
    for (i = 0; ; i++) {
      // malleate tx and thus sighash to satisfy constraint
      tx.nLockTime = i;
      const preimage_ = getPreimage(tx, lockingScriptASM, satValue, idx, sighashType);
      preimageHex = toHex(preimage_);
      preimage = preimage_;
      const h = bsv.crypto.Hash.sha256sha256(Buffer.from(preimageHex, 'hex'));
      const msb = h.readUInt8();
      if (msb < MSB_THRESHOLD) {
        // the resulting MSB of sighash must be less than the threshold
        break;
      }
    }
  } else {
    preimage = getPreimage(tx, lockingScriptASM, satValue, idx, sighashType);
  }
  return preimage;
}

function buildNFTMintMetadataOpReturn() {
  return bsv.Script.fromASM(`OP_FALSE OP_RETURN ${Buffer.from("Image: https://i1.sndcdn.com/artworks-000299901567-oiw8tq-t500x500.jpg", 'utf8').toString('hex')}`);
}

function buildMetadataOpReturn(someData = 'hello world') {
  return bsv.Script.fromASM(`OP_FALSE OP_RETURN ${Buffer.from(someData, 'utf8').toString('hex')}`);
}

/**
 * Replace the asset and PKH arguments of the locking script.
 * @param {*} asm The locking script as generated by scrypt compiler
 * @param {*} asset The assetid
 * @param {*} pkh the pubKeyHash
 */
function replaceAssetAndPkh(asm, asset, pkh) {
  const replacedAssetPkh = asset + ' ' + pkh + asm.toASM().substring(113); 
  return bsv.Script.fromASM(replacedAssetPkh);
}

const sleeper = async(seconds) => {
  return new Promise((resolve) => {
     setTimeout(() => {
        resolve();
     }, seconds * 1000);
  })
}

// SuperAssetNFT
//
// Non-Fungible-Token (NFT) Smart Contract for Bitcoin.
// ----------------------------------------------------------------------------------------------
//
// Key Features of SuperAssetNFT:
//     - Mint, transfer, update, and transform(melt) NFTs.
//     - Supports seperate funding inputs and change outputs with ANYONECANPAY
//     - Store arbitrary data payloads (HTML, JSON, Protobuf, PDFs, images, XML, etc)
//     - Replay protection with globally unique ID passed on as an 'identity baton'
//     - Can destroy or transform the token via "transform(melt)" and retrieve the satoshis
//     - Identical trust guarantees as a regular UTXO
//     - Developers can easily verify authenticity and asset history by requesting it in it's entirety from the seller
//     - Wallets and indexers can proactively index these UTXO's via a blind pattern match for the minting pattern
//     - Simplfied Payment Verification (SPV) and 0-conf works as expected with all the properties afforded to the native satoshi
//     - Use of SIGHASH_SINGLE allows token to be composable with other smart contracts
//     - Polymorphism is made possible because the data state (assetID and ownerAddress) appears at the beginning of the contract layout
//     - Small footprint of 242 bytes (release) or 252 bytes (debug)
//
//  Contract Code and State Layout:
//  ============================================================================
//                       
//  assetID(36B) ownerPkh(20B) | SuperAssetNFT STATIC CODE
//                       
//  ============================================================================
//
// Example Deploy Transaction: https://www.whatsonchain.com/tx/df366000a99c81d64701a492b3730cd72b27325c419c48f929dc710ccc855448
// Example Mint Transaction: https://www.whatsonchain.com/tx/147346d56b55e872a0e4a983bbcfd9fddfaacd866b1df5f84e30f7c2d9d41473
// Example Transfer Transaction: https://www.whatsonchain.com/tx/f53b7abe63efd24d268a703e30d3456caa87b71985ae5e7ee99a3d0f29152b0f
// Example Melt Transaction:Â https://www.whatsonchain.com/tx/fe3e64a329ccbf7638c110f28c4dab71df397d0d2ad8b4003ed4fa43e423cf16
async function main() {
  try {
    const publicKey = privateKey.publicKey
 
    // If changing to 'release' then update the outputSize to 'f2' (to reflect smaller output size). Use 'fc' for debug.
    const outputSize = 'fc'; // Change to fc for debug or f2 for release
    const SuperAssetNFT = buildContractClass(loadDesc('SuperAssetNFT_debug_desc.json')); 
    const publicKeyHash = bsv.crypto.Hash.sha256ripemd160(publicKey.toBuffer())
    const nft = new SuperAssetNFT(new Bytes('000000000000000000000000000000000000000000000000000000000000000000000000'), new Ripemd160(toHex(publicKeyHash)));
    const asmVars = {
      'Tx.checkPreimageOpt_.sigHashType': 
      sighashType2Hex(sighashType)
    };  
    nft.replaceAsmVars(asmVars);
    console.log('NFT Template', nft, new Ripemd160(toHex(publicKeyHash)));
    // Step 1.
    // deploy contract on testnet

    let nftAmount = 10000;
    let prevNftAmount = nftAmount;
    let prevLockingScript = nft.lockingScript;
    console.log('About to deploy (pre-mint) nft...', prevLockingScript.toASM())
    const deployTx = await deployContract(nft, nftAmount);

    console.log('Deploy txid:     ', woc + deployTx.id)
    // We must reverse the endianness of the printed txid to match the outpoint format in the raw tx
    const mintAssetId = Buffer.from(deployTx.id, 'hex').reverse().toString('hex') + '00000000';
    console.log('assetId (outpoint):     ', mintAssetId)

    // call contract method on testnet
    const mintTx = new bsv.Transaction();

    // Step 2.
    // mint the asset
    console.log('About to mint nft...', mintTx.toString())

    await sleeper(1);

    const newLockingScript = replaceAssetAndPkh(nft.lockingScript, mintAssetId, privateKey.toAddress().toHex().substring(2));  
    mintTx.addInput(createInputFromPrevTx(deployTx))
    .setOutput(0, (tx) => {
      nftAmount = nftAmount - tx.getEstimateFee();
      return new bsv.Transaction.Output({
        script: newLockingScript,
        satoshis: nftAmount,
      });
    })
   // Optionally include any number of outputs
   .setOutput(1, (tx) => {
      const deployData = buildNFTMintMetadataOpReturn()
      return new bsv.Transaction.Output({
        script: deployData,
        satoshis: 0,
      }) 
    })
    .setInputScript(0, (tx, output) => {
      const preimage = generatePreimage(true, tx, prevLockingScript, output.satoshis, sighashType);
      // Update prev locking script
      const outputSatsWithSize = new Bytes(num2bin(nftAmount, 8) + `${outputSize}24`);
      console.log('preimage', preimage);
      console.log('output.script', output.script.toASM());
      console.log('output.satoshis', output.satoshis);
      console.log('outputSatsWithSize', outputSatsWithSize);
      console.log('isTransform', new Bool(false));
      console.log('receiveAddress', new Bytes(privateKey.toAddress().toHex().substring(2)));
      console.log('unlock pubKey', new PubKey(toHex(publicKey)));
      const sig = signTx(tx, privateKey, output.script, output.satoshis, 0, sighashType);
      console.log('sig', sig);
      return nft.unlock(preimage, outputSatsWithSize, new Bytes('14' + privateKey.toAddress().toHex().substring(2)), new Bool(false), sig, new PubKey(toHex(publicKey))).toScript()
    })
    .seal()

    console.log('mintTx', mintTx.toString());
    const mintTxid = await sendTx(mintTx)
    console.log('Mint txid: ', woc + mintTxid)
    prevLockingScript = newLockingScript;

    // Step 3.
    // Transfer ownership
    console.log('About to transfer nft...')
    await sleeper(1);
    // call contract method on testnet
    const transferTX = new bsv.Transaction();
    transferTX.addInput(createInputFromPrevTx(mintTx, 0))
      .setOutput(0, (tx) => {
        nftAmount = nftAmount - tx.getEstimateFee();
        return new bsv.Transaction.Output({
          script: newLockingScript,
          satoshis: nftAmount, // Set a fee to handle it all
        })
      })
      .setOutput(1, (tx) => {
        const deployData = buildMetadataOpReturn()
        return new bsv.Transaction.Output({
          script: deployData,
          satoshis: 0,
        })
      })
      .setInputScript(0, (tx, output) => {
        const preimage = generatePreimage(true, tx, prevLockingScript, output.satoshis, sighashType);
        const outputSatsWithSize = new Bytes(num2bin(nftAmount, 8) + `${outputSize}24`);
        console.log('preimage', preimage);
        console.log('output.script', output.script.toASM());
        console.log('output.satoshis', output.satoshis);
        console.log('outputSatsWithSize', outputSatsWithSize);
        console.log('isTransform', new Bool(false));
        console.log('receiveAddress', new Bytes(privateKey.toAddress().toHex().substring(2)));
        console.log('unlock pubKey', new PubKey(toHex(publicKey)));
        const sig = signTx(tx, privateKey, output.script, output.satoshis, 0, sighashType);
        console.log('sig', sig);
        return nft.unlock(preimage, outputSatsWithSize, new Bytes('14' + privateKey.toAddress().toHex().substring(2)), new Bool(false), sig, new PubKey(toHex(publicKey))).toScript()
      })
      .seal()

    console.log('transferTX', transferTX.toString());
    const transferTxid = await sendTx(transferTX)
    console.log('Transfer txid: ', woc + transferTxid)
    prevLockingScript = newLockingScript;

    // Step 4.
    // Melt
    console.log('About to melt nft...')
    await sleeper(1);
    // call contract method on testnet
    const meltTX = new bsv.Transaction();
    meltTX.addInput(createInputFromPrevTx(transferTX, 0))
      .setOutput(0, (tx) => {
        const newLockingScript = bsv.Script.buildPublicKeyHashOut(privateKey.toAddress());
        nftAmount = nftAmount - tx.getEstimateFee();
        return new bsv.Transaction.Output({
          script: newLockingScript,
          satoshis: nftAmount, // Set a fee to handle it all
        })
      })
      .setInputScript(0, (tx, output) => {
        const preimage = generatePreimage(true, tx, prevLockingScript, output.satoshis, sighashType);
        const outputSatsWithSize = new Bytes(num2bin(nftAmount, 8) + `${outputSize}24`);
        console.log('preimage', preimage);
        console.log('output.script', output.script.toASM());
        console.log('output.satoshis', output.satoshis);
        console.log('outputSatsWithSize', outputSatsWithSize);
        console.log('isTransform', new Bool(true));
        console.log('receiveAddress', new Bytes(privateKey.toAddress().toHex().substring(2)));
        console.log('unlock pubKey', new PubKey(toHex(publicKey)));
        const sig = signTx(tx, privateKey, output.script, output.satoshis, 0, sighashType);
        console.log('sig', sig);
        return nft.unlock(preimage, outputSatsWithSize, new Bytes('14' + privateKey.toAddress().toHex().substring(2)), new Bool(true), sig, new PubKey(toHex(publicKey))).toScript()
      })
      .seal()

    console.log('meltTx', meltTX.toString());
    const meltTxid = await sendTx(meltTX)
    console.log('Melt txid: ', woc + meltTxid)
  } catch (error) {
    console.log('Failed on testnet')
    showError(error)
  }
}

main()